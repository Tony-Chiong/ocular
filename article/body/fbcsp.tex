\section{Filter Bank Common Spatial Patterns}
\todo{You should describe a bit more about Filter Bank and Multi Class CSP, at least 2 paragraphs for each technique.}
We have chosen to use a Filter bank multi class common spatial patterns (FBMCCSP) algorithm, for the purpose of extracting features from EEG data. The CSP algorithm has been used in many EEG classification studies within recent years, as in \cite{ang2012filter}. In all studies,\todo{source?} CSP were considered a step of improvement to the classification of EEG classes. Based on these results, we chose to incorporate CSP as part of the classification pipeline. CSP assumes the user knows which frequency ranges contains important features for different imagery classes. Since one rarely knows of these ranges, we have implemented the filter bank algorithm, as a step before CSP, as this automatically chooses frequency ranges from EEG data. Filter bank is also a well studied algorithm, which is often used in conjunction with CSP, as in \cite{ang2008filter}. CSP can in its original form, only be used in binary classification problems, but the extension explained in this paper, multi class CSP (MCCSP), does not have that restriction. Since MCCSP makes use of the original binary CSP, we first explain how CSP works, and then extend it with multi class.

\begin {figure*}%[!hbtp]
\centering
\begin{adjustbox}{width=\textwidth}
\begin{tikzpicture}

% Variables
\pgfmathsetmacro{\bs}{0.5};
\pgfmathsetmacro{\boxl}{2};
\pgfmathsetmacro{\boxh}{1};
\pgfmathsetmacro{\ll}{1};
\coordinate (blength) at (0.5, 0);
\coordinate (linel) at (1, 0);
\coordinate (bh) at (0, 1);
\coordinate (bl) at (2, 0);
\newcommand*{\fblist}{-3, 0, 3}
\newcommand*{\csplist}{-1, 0, 1}
\newcommand*{\ovrlist}{{af},{bo},{co}}
	

% Coordinate for start circle
\coordinate (trains) at (0, 0);

% Coordinate for Bayesian Optimization
\coordinate (bos) at ($(trains) + (blength) + 3/2*(linel)$);

% Coordinate for cross validation
\coordinate (crosss) at ($(bos) + (blength) + 3/2*(linel) + 1/2*(bl)$);

% Coordinate for Ocular Articaft Correction
\coordinate (oacls) at ($(crosss) + (bl) + (linel)$);

% Coordinate for Filter Bank
\coordinate (filters) at ($(oacls) + (bl) + (linel)$);

% Coordinate for filterbank nodes
\coordinate (filterbanks) at ($(filters) + 1/2*(bl) + 1.5*(linel) + 1/2*(blength)$);

% Coordinate for csp ovr nodes
\coordinate (cspovrs) at ($(filterbanks) + 1/2*(blength) + (linel)$);

% Coordinate for Random Forest Learner nodes
\coordinate (randomforestlearner) at ($(cspovrs) + 1/2*(blength) + 3.5*(linel)$);

% Coordinate for result node
\coordinate (results) at ($(randomforestlearner) + 1/2*(bl) + 1/2*(blength) + (linel)$);

% Coordinate for mean results
\coordinate (meanresults) at ($(results) + (blength) + (linel)$);

% Cooordinates for start and end of step box
\coordinate (boxceil) at (0, 6);
\coordinate (boxfloor) at (0, -6);
\coordinate (startbox) at ($(trains) + (-1, 0)$);
\coordinate (endbox) at ($(meanresults) + (1, 0)$);


% Draw training data circle
\node [draw, label={Train Data}, circle, name=traincircle, minimum size = \bs] at (trains) {};

% Draw Bayesian Optimization Box
\node (bo) at (bos) [draw,thick,minimum width=\boxl cm,minimum height=\boxh cm] {BO};
\draw [->] (traincircle) -- (bo);

% Draw Cross validation box
\node (crossvalidation) at (crosss) [draw,thick,minimum width=\boxl cm,minimum height=\boxh cm] {CV};
\draw [->] (bo) -- (crossvalidation);

% Draw oacl box
\node (oacl) at (oacls) [draw,thick,minimum width=\boxl cm,minimum height=\boxh cm] {OAC};
\draw [->] (crossvalidation) -- (oacl);

% Draw Filter Bank
\node (filterbank) at (filters) [draw,thick,minimum width=\boxl cm,minimum height=\boxh cm] {FB};
\draw [->] (oacl) -- (filterbank);

% Draw filterbank nodes
\foreach \x in \fblist{
	\node [draw, circle, name=filterbanknode\x, minimum size = \bs] at ($(filterbanks) + (0, \x)$) {};
}

\draw [->] (filterbank) -- node[above] {[4, 8]} (filterbanknode-3);
\draw [->] (filterbank) -- node[above] {[8, 12]} (filterbanknode0);
\draw [->] (filterbank) -- node[above] {[12, 16]} (filterbanknode3);

% Draw Filter Bank Nodes and CSP OVR nodes
\foreach \x in \fblist
	\foreach \y in \csplist{
		\node [draw, circle, name=cspovrnode\x\y, minimum size = \bs] at ($(filterbanknode\x) + (0, \y) + 2*(linel)$) {};
		\draw [->] (filterbanknode\x) -- (cspovrnode\x\y);
}

% Draw names of csp
\foreach \x in \fblist{
	\draw [->] (filterbanknode\x) -- node[above] {1-23} (cspovrnode\x-1);
	\draw [->] (filterbanknode\x) -- node[above] {2-13} (cspovrnode\x0);
	\draw [->] (filterbanknode\x) -- node[above] {3-12} (cspovrnode\x1);
}


% Draw filter bands
\noindent\foreach [count=\i] \x in \fblist{
	\draw [->] (filterbank) -- node[above] {} (filterbanknode\x);
}

% Draw random forest classifier node
\node (randomforestnode) at (randomforestlearner) [draw,thick,minimum width=\boxl cm,minimum height=\boxh cm] {RFC};

% Draw CSP OVR arrows to classifier node
\foreach \x in \fblist
\foreach \y in \csplist{
	\draw [->] (cspovrnode\x\y) -- (randomforestnode);
}

% Draw result node
\node [draw, label={Fold result}, circle, name=result, minimum size = \bs] at (results) {};
\draw [->] (randomforestnode) -- (result);

% Draw mean result node
\node [draw, label={south:Mean Result}, circle, name=meanresult, minimum size = \bs] at ($(meanresults) + (0, -1)$) {};
\draw [->] (result) -- (meanresult);

% Draw curved arrows
\draw [->] (result) to[out=270, in=270, distance=165] (crossvalidation);
\draw [->] (meanresult) to[out=270, in=270, distance=180] (bo);

% Draw box around image and horizontal lines
\draw ($(startbox) + (boxfloor)$) -- ($(endbox) + (boxfloor)$) -- ($(endbox) + (boxceil)$) -- ($(startbox) + (boxceil)$) -- cycle;

\draw[loosely dotted] ($(trains) + (boxfloor) + 1/2*(linel)$) -- ($(trains) + (boxceil) + 1/2*(linel)$);
\node[draw] at ($(trains) + (boxceil) - (0, 1)$) {1};

\draw[loosely dotted] ($(bos) + (boxfloor) + 3/2*(linel)$) -- ($(bos) + (boxceil) + 3/2*(linel)$);
\node[draw] at ($(bos) + (boxceil) - (0, 1)$) {2};

\draw[loosely dotted] ($(crosss) + (boxfloor) + 3/2*(linel)$) -- ($(crosss) + (boxceil) + 3/2*(linel)$);
\node[draw] at ($(crosss) + (boxceil) - (0, 1)$) {3};

\draw[loosely dotted] ($(oacls) + (boxfloor) + 3/2*(linel)$) -- ($(oacls) + (boxceil) + 3/2*(linel)$);
\node[draw] at ($(oacls) + (boxceil) - (0, 1)$) {4};

\draw[loosely dotted] ($(filters) + (boxfloor) + 3/2*(linel)$) -- ($(filters) + (boxceil) + 3/2*(linel)$);
\node[draw] at ($(filters) + (boxceil) - (0, 1)$) {5};

\draw[loosely dotted] ($(filters) + (boxfloor) + 15/4*(linel)$) -- ($(filters) + (boxceil) + 15/4*(linel)$);
\node[draw] at ($(filters) + (boxceil) - (0, 1) +11/4*(linel)$) {6};

\draw[loosely dotted] ($(filterbanks) + (boxfloor) + 3*(linel)$) -- ($(filterbanks) + (boxceil) + 3*(linel)$);
\node[draw] at ($(filterbanks) + (boxceil) - (0, 1) +2*(linel)$) {7};

\draw[loosely dotted] ($(randomforestlearner) + (boxfloor) + 3/2*(linel)$) -- ($(randomforestlearner) + (boxceil) + 3/2*(linel)$);
\node[draw] at ($(randomforestlearner) + (boxceil) - (0, 1)$) {8};

\draw[loosely dotted] ($(result) + (boxfloor) + 2/3*(linel)$) -- ($(result) + (boxceil) + 2/3*(linel)$);
\node[draw] at ($(result) + (boxceil) - (0, 1)$) {9};

\node[draw] at ($(meanresults) + (boxceil) - (0, 1)$) {10};

\end{tikzpicture}
\end{adjustbox}
\caption{Overview of program pipeline}
\label{fig:ProgramPipeline}
\end{figure*}

\subsection{Common Spatial Patterns}\label{sec:csp}
CSP finds spatial filters, which when applied to signals, gives the maximal mutual information between these, with respect to signal variance. The method assumes there are classification information hidden within the variance between signals. Assuming we are classifying on motor imagery for different body parts, as we are in the training and evaluation data, this assumption can be justified \citep{blankertz2008optimizing}.
Formally CSP combines data trials with the same imagery task. Let $\pmb{A}$ and $\pmb{B}$ be matrices of combined trials for imagery task 1 and 2 respectively,

\begin{equation}
\label{eq:csp_data}
\pmb{A}, \mathbf{B} \in \mathbb{R}^{n*m}
\end{equation}
where $n$ and $m$ are the number of signals and samples respectively. CSP now calculates the covariance matrices for $\pmb{A}$ and $\pmb{B}$,

\begin{equation}
\label{eq:covariance_matrice}
\pmb{A_{cov}} = \frac{(\pmb{A} \cdot \overline{\pmb{A}})^\mathsf{T}  \cdot (\pmb{A} \cdot \overline{\pmb{A}})}{m - 1}
\end{equation}
where $m$ is the number of samples in $\pmb{A}$, and elements of $\overline{\pmb{A}}$ is defined as,

\begin{equation}
\label{eq:a_bar}
\pmb{\overline{A}_{ij}} = \frac{\pmb{A_{i,1}} + \pmb{A_{i,2}} + ... + \pmb{A_{i,m}}}{m}
\end{equation}

By applying simultaneous diagonalization between $\pmb{A_{cov}}$ and $\pmb{B_{cov}}$, we form the eigenvectors $\pmb{P}$, which will be the spatial filters for maximizing variance between class 1 and 2. $\pmb{P}$ is found when both of the following diagonalizations hold, 

\begin{equation}
\label{eq:diagonalization_A}
\pmb{P} \cdot \pmb{A_{cov}} \cdot \pmb{P} = \pmb{D}, \quad \pmb{P}, \pmb{D}, \pmb{A_{cov}} \in \mathbb{R}^{n*n}
\end{equation}

\begin{equation}
\label{eq:diagonalization_B}
\pmb{P} \cdot \pmb{B_{cov}} \cdot \pmb{P} = \pmb{I}, \quad \pmb{P}, \pmb{I}, \pmb{B_{cov}} \in \mathbb{R}^{n*n}
\end{equation}

The spatial filter will now correspond to the first row of $\pmb{P}$, such that $\pmb{\vec{w}} = \pmb{P}^\mathsf{T}_{1}$ 

$\pmb{P}$ can now be used as a linear transformation which when applied to EEG signals, maps these into a new space, where signal features are more discriminative. The drawback of CSP is that it does not work well if the frequency bands are not adjusted to fit each subject \citep{novi2007sub}. Furthermore, CSP only works for two classes, whereas many real world applications require a greater number of classes.

\subsection{Filter bank}
Finding good frequency bands for each subject can be quite time-consuming when done manually. Fortunately, the process can be automated by creating a filter bank (FB) that splits a signal into components, each of which contains a frequency sub-band. This can be seen in \cref{fig:ProgramPipeline} as step 5.

The sub-bands are chosen within the frequency range of 4 to 40, which should assure all relevant data is taken into account \citep{pfurtscheller1999event}. They are chosen with an interval of $n \in \{3,..,8\}$. For an interval of $n = 3$ we would create a set $F$ of filtersss, $F \in \{[4, 7], [7, 10],...,[37, 40]\}$. Every filter will be used in the creation of CSPs, which will form the basis of feature extraction.

\subsection{Multi-class CSP}
We introduce MCCSP by the one versus rest (OVR) method. The method constructs one CSP per class, by choosing a class, and treating every other class as being the same. This way we get one CSP per imagery class, each constructed to create the maximum variance to all other classes. The method is depicted in \Cref{fig:ProgramPipeline} as step 6. The example figure shows a pipeline with 3 filter bands, and three classes, from which 9 CSP are created. EEG features can now be found, by applying the spatial filters from CSP, to EEG trials. Our approach is to apply each CSP, to every trial, and combine all of their respective feature vectors. As an example, say we have $m$ CSP, after applying OVR over all classes, for all bands. If now we apply one of the $m$ CSP to a single trial, we get a feature vector with $n$ components. By applying all CSP to the same trial, and combining their feature vectors, we get a trial with $n * m$ features. We apply this method on all trials in the dataset, from where $n * m$ features are found, for every trial. These can now be used to train a random forest classifier.     







